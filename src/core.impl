
#ifdef LISP_NAMESPACE
namespace LISP_NAMESPACE {
#endif

class CoreImpl
{
public:
    CoreImpl(SymbolImpl & symbol, SymbolImpl & keyword) : m_symbol(symbol), m_keyword(keyword)
    {
    }

    Expr intern(char const * name)
    {
        if (!strcmp("nil", name))
        {
            return nil;
        }
        else if (name[0] == ':')
        {
            return make_keyword(name + 1);
        }
        else
        {
            return make_symbol(name);
        }
    }

protected:
    Expr make_symbol(char const * name)
    {
        return m_symbol.make(name);
    }

    Expr make_keyword(char const * name)
    {
        return m_keyword.make(name);
    }

private:
    SymbolImpl & m_symbol;
    SymbolImpl & m_keyword;
};

#if LISP_WANT_GLOBAL_API

CoreImpl g_core(g_symbol, g_keyword);

Expr intern(char const * name)
{
    return g_core.intern(name);
}

bool is_named_call(Expr exp, Expr name)
{
    return is_cons(exp) && eq(car(exp), name);
}

bool is_quote_call(Expr exp)
{
    return is_named_call(exp, intern("quote"));
}

bool is_unquote(Expr exp)
{
    return is_named_call(exp, LISP_SYM_UNQUOTE);
}

bool is_unquote_splicing(Expr exp)
{
    return is_named_call(exp, LISP_SYM_UNQUOTE_SPLICING);
}

Expr list(Expr exp1)
{
    return cons(exp1, nil);
}

Expr list(Expr exp1, Expr exp2)
{
    return cons(exp1, cons(exp2, nil));
}

Expr list(Expr exp1, Expr exp2, Expr exp3)
{
    return cons(exp1, cons(exp2, cons(exp3, nil)));
}

Expr list(Expr exp1, Expr exp2, Expr exp3, Expr exp4, Expr exp5)
{
    return cons(exp1, cons(exp2, cons(exp3, cons(exp4, cons(exp5, nil)))));
}

#endif

#ifdef LISP_NAMESPACE
}
#endif
