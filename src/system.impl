
/* system */

#ifdef LISP_NAMESPACE
namespace LISP_NAMESPACE {
#endif

U32 utf8_decode_one(U8 const * buf)
{
    U8 ch = *buf++;
    if (ch < 0x80)
    {
        return ch;
    }

    // TODO check for leading 0b10 in continuation bytes

    U32 val = 0;
    if ((ch >> 5) == 0x6)
    {
        val |= ch & 0x1f;

        ch = *buf++;
        val <<= 6;
        val |= (ch & 0x3f);
    }
    else if ((ch >> 4) == 0xe)
    {
        val |= ch & 0xf;

        ch = *buf++;
        val <<= 6;
        val |= (ch & 0x3f);

        ch = *buf++;
        val <<= 6;
        val |= (ch & 0x3f);
    }
    else if ((ch >> 3) == 0x1e)
    {
        val |= ch & 0x7;

        ch = *buf++;
        val <<= 6;
        val |= (ch & 0x3f);

        ch = *buf++;
        val <<= 6;
        val |= (ch & 0x3f);

        ch = *buf++;
        val <<= 6;
        val |= (ch & 0x3f);
    }
    else
    {
        LISP_FAIL("illegal utf-8 string\n", val);
    }

    if (val >= 0xd800 && val < 0xe000)
    {
        LISP_FAIL("illegal surrogate pair %" PRIu32 " in utf-8 string\n", val);
    }

    return val;
}

class SystemImpl
{
public:
    SystemImpl() :
        m_dummy(0)
    {
        // TODO move to type_init?
        LISP_ASSERT_ALWAYS(TYPE_NIL == make_type("nil"));
        LISP_ASSERT_ALWAYS(TYPE_CHAR == make_type("char"));
        LISP_ASSERT_ALWAYS(TYPE_FIXNUM == make_type("fixnum"));
        LISP_ASSERT_ALWAYS(TYPE_SYMBOL == make_type("symbol"));
        LISP_ASSERT_ALWAYS(TYPE_KEYWORD == make_type("keyword"));
        LISP_ASSERT_ALWAYS(TYPE_CONS == make_type("cons"));
#if LISP_WANT_GENSYM
        LISP_ASSERT_ALWAYS(TYPE_GENSYM == make_type("gensym"));
#endif
#if LISP_WANT_POINTER
        LISP_ASSERT_ALWAYS(TYPE_POINTER == make_type("pointer"));
#endif
        LISP_ASSERT_ALWAYS(TYPE_STRING == make_type("string"));
        LISP_ASSERT_ALWAYS(TYPE_STREAM == make_type("stream"));
        LISP_ASSERT_ALWAYS(TYPE_BUILTIN_SPECIAL == make_type("builtin-special"));
        LISP_ASSERT_ALWAYS(TYPE_BUILTIN_FUNCTION == make_type("builtin-function"));
        LISP_ASSERT_ALWAYS(TYPE_BUILTIN_SYMBOL == make_type("builtin-symbol"));
    }

    virtual ~SystemImpl()
    {
    }

    /* core */

    void load_file(char const * path, Expr env)
    {
        Expr const in = make_file_input_stream_from_path(path);
        Expr exp = nil;
        while (maybe_parse_expr(in, &exp))
        {
            eval(exp, env);
        }
        stream_release(in);
    }

    void repl(Expr env)
    {
        // TODO make a proper prompt input stream
        Expr in = stream_get_stdin();
    loop:
        {
            /* read */
            // TODO use global.stream.stdout
            fprintf(stdout, "> ");
            fflush(stdout);

            Expr exp = nil;
            if (!maybe_parse_expr(in, &exp))
            {
                goto done;
            }

            /* eval */
            Expr ret = eval(exp, env);

            /* print */
            println(ret);

            goto loop;
        }
    done:
        ;
    }

    virtual Expr make_core_env()
    {
        Expr env = make_env(nil);

        env_def(env, intern("t"), intern("t"));

        env_defsym(env, "*env*", [](Expr, Expr env) -> Expr
        {
            return env;
        });

        env_defspecial_quote(env);

        env_defspecial(env, "if", [this](Expr args, Expr env) -> Expr
        {
            if (eval(car(args), env) != nil)
            {
                return eval(cadr(args), env);
            }
            else if (cddr(args))
            {
                return eval(caddr(args), env);
            }
            else
            {
                return nil;
            }
        });

        env_defspecial_while(env);

        env_defspecial(env, "def", [this](Expr args, Expr env) -> Expr
        {
            env_def(env, car(args), eval(cadr(args), env));
            return nil;
        });

        env_defspecial(env, "lambda", [this](Expr args, Expr env) -> Expr
        {
            Expr const fun_args = car(args);
            Expr const fun_body = cdr(args);
            return make_function(env, nil, fun_args, fun_body);
        });

        env_defspecial(env, "syntax", [this](Expr args, Expr env) -> Expr
        {
            Expr const mac_args = car(args);
            Expr const mac_body = cdr(args);
            return make_macro(env, nil, mac_args, mac_body);
        });

        env_defspecial(env, "backquote", [this](Expr args, Expr env) -> Expr
        {
            return backquote(car(args), env);
        });

        env_defun(env, "eq", [this](Expr args, Expr) -> Expr
        {
            return all_eq(args) ? LISP_SYMBOL_T : nil; // TODO use make_truth()
        });

        env_defun(env, "equal", [this](Expr args, Expr) -> Expr
        {
            return all_equal(args) ? LISP_SYMBOL_T : nil; // TODO use make_truth()
        });

        env_defun(env, "cons", [this](Expr args, Expr) -> Expr
        {
            return cons(car(args), cadr(args));
        });

        env_defun(env, "car", [this](Expr args, Expr) -> Expr
        {
            return car(car(args));
        });

        env_defun(env, "cdr", [this](Expr args, Expr) -> Expr
        {
            return cdr(car(args));
        });

        env_defun(env, "rplaca", [this](Expr args, Expr) -> Expr
        {
            rplaca(car(args), cadr(args));
            return nil;
        });

        env_defun(env, "rplacd", [this](Expr args, Expr) -> Expr
        {
            rplacd(car(args), cadr(args));
            return nil;
        });

        env_defun_println(env, "println");

        env_defun(env, "intern", [this](Expr args, Expr) -> Expr
        {
            return intern(string_value(car(args)));
        });

#if LISP_WANT_GENSYM
        env_defun(env, "gensym", [this](Expr, Expr) -> Expr
        {
            return gensym();
        });
#endif

#if LISP_WANT_POINTER
        env_defun(env, "fopen", [this](Expr args, Expr) -> Expr
        {
            // TODO use builtin_arg1(name, args) for better error checking
            Expr const path = first(args);
            Expr const mode = second(args);
            return make_pointer(fopen(string_value(path), string_value(mode)));
        });

        env_defun(env, "fclose", [this](Expr args, Expr) -> Expr
        {
            // TODO use builtin_arg1(name, args) for better error checking
            Expr const file = first(args);
            fclose((FILE *) pointer_value(file));
            return nil;
        });

        env_defun(env, "write-u8", [this](Expr args, Expr) -> Expr
        {
            Expr const file = first(args);
            Expr const value = second(args);
            U8 const val = fixnum_value(value); // TODO use, say, expr_to_u8()
            fwrite(&val, 1, 1, (FILE *) pointer_value(file));
            return nil;
        });
#endif

        env_defun(env, "load-file", [this](Expr args, Expr env) -> Expr
        {
            load_file(string_value(first(args)), env);
            return nil;
        });

        env_defun(env, "ord", [this](Expr args, Expr) -> Expr
        {
            return make_number(utf8_decode_one(string_value_utf8(car(args))));
        });

        env_defun(env, "chr", [this](Expr args, Expr) -> Expr
        {
            return make_string_from_utf32_char((U32) fixnum_value(car(args)));
        });

        env_defun(env, "type", [this](Expr args, Expr) -> Expr
        {
            Expr const arg1 = car(args);
            return intern(type_name(expr_type(arg1)));
        });

        return env;
    }

    void env_defspecial_quote(Expr env)
    {
        env_defspecial(env, "quote", [this](Expr args, Expr) -> Expr
        {
            return car(args);
        });
    }

    void env_defspecial_while(Expr env)
    {
        env_defspecial(env, "while", [this](Expr args, Expr env) -> Expr
        {
            Expr const test = car(args);
            Expr const body = cdr(args);

            // TODO do we want to return a value?
            while (eval(test, env))
            {
                eval_body(body, env);
            }
            return nil;
        });
    }

    void env_defun_println(Expr env, char const * name)
    {
        env_defun(env, name, b_println);
    }

    /* type */

    U64 make_type(char const * name)
    {
        return m_type.make(name);
    }

    char const * type_name(U64 type)
    {
        return m_type.name(type);
    }

    /* util */

    // TODO use is_named_call()
    bool is_op(Expr exp, Expr name)
    {
        return is_cons(exp) && car(exp) == name;
    }

    bool is_quote(Expr exp)
    {
        return is_op(exp, LISP_SYM_QUOTE);
    }

    bool is_if(Expr exp)
    {
        return is_op(exp, LISP_SYM_IF);
    }

    bool all_equal(Expr exps)
    {
        if (is_nil(exps))
        {
            LISP_FAIL("not enough arguments in call to equal: %s\n", repr(exps));
        }
        Expr prv = car(exps);
        Expr tmp = cdr(exps);
        if (is_nil(tmp))
        {
            LISP_FAIL("not enough arguments in call to equal: %s\n", repr(exps));
        }

        for (; tmp; tmp = cdr(tmp))
        {
            let exp = car(tmp);
            if (!equal(prv, exp))
            {
                return false;
            }
            prv = exp;
        }

        return true;
    }

    bool all_eq(Expr exps)
    {
        if (is_nil(exps))
        {
            LISP_FAIL("not enough arguments in call to eq: %s\n", repr(exps));
        }
        var prv = car(exps);
        var tmp = cdr(exps);
        if (is_nil(tmp))
        {
            LISP_FAIL("not enough arguments in call to eq: %s\n", repr(exps));
        }

        for (; tmp; tmp = cdr(tmp))
        {
            let exp = car(tmp);
            if (!eq(prv, exp))
            {
                return false;
            }
            prv = exp;
        }

        return true;
    }

    /* reader */

    void env_destructuring_bind(Expr env, Expr vars, Expr vals)
    {
        if (vars == nil)
        {
            if (vals != nil)
            {
                LISP_FAIL("no more parameters to bind\n");
            }
        }
        else if (is_cons(vars))
        {
            while (vars)
            {
                if (is_cons(vars))
                {
                    LISP_ASSERT(is_cons(vals));
                    env_destructuring_bind(env, car(vars), car(vals));
                    vars = cdr(vars);
                    vals = cdr(vals);
                }
                else
                {
                    env_destructuring_bind(env, vars, vals);
                    break;
                }
            }
        }
        else
        {
            env_def(env, vars, vals);
        }
    }

    void env_defun(Expr env, char const * name, BuiltinFunc func)
    {
        env_def(env, intern(name), make_builtin_function(name, func));
    }

    void env_defspecial(Expr env, char const * name, BuiltinFunc func)
    {
        env_def(env, intern(name), make_builtin_special(name, func));
    }

    void env_defsym(Expr env, char const * name, BuiltinFunc func)
    {
        env_def(env, intern(name), make_builtin_symbol(name, func));
    }

    /* eval */

    Expr eval(Expr exp, Expr env)
    {
        switch (expr_type(exp))
        {
        case TYPE_NIL:
        case TYPE_CHAR:
        case TYPE_FIXNUM:
        case TYPE_STRING:
        case TYPE_KEYWORD:
#if LISP_WANT_POINTER
        case TYPE_POINTER:
#endif
            return exp;
        case TYPE_SYMBOL:
#if LISP_WANT_GENSYM
        case TYPE_GENSYM:
#endif
            return env_get(env, exp);
        case TYPE_CONS:
            return apply(car(exp), cdr(exp), env);
        case TYPE_BUILTIN_SYMBOL:
            return builtin_func(exp)(nil, env);
        default:
            LISP_FAIL("cannot evaluate %s\n", repr(exp));
            return nil;
        }
    }

    Expr eval_list(Expr exps, Expr env)
    {
        Expr ret = nil;
        for (Expr tmp = exps; tmp; tmp = cdr(tmp))
        {
            Expr const exp = car(tmp);
            ret = cons(eval(exp, env), ret);
        }
        return nreverse(ret);
    }

    Expr eval_body(Expr exps, Expr env)
    {
        Expr ret = nil;
        for (Expr tmp = exps; tmp; tmp = cdr(tmp))
        {
            Expr const exp = car(tmp);
            ret = eval(exp, env);
        }
        return ret;
    }

    Expr apply(Expr name, Expr args, Expr env)
    {
        if (is_builtin_function(name))
        {
            return builtin_func(name)(eval_list(args, env), env);
        }
        else if (is_builtin_special(name))
        {
            return builtin_func(name)(args, env);
        }
        else if (is_function(name))
        {
            return eval_body(closure_body(name),
                             make_call_env_from(closure_env(name),
                                                closure_args(name),
                                                eval_list(args, env)));
        }
        else if (is_macro(name))
        {
            return eval(eval_body(closure_body(name),
                                  make_call_env_from(closure_env(name),
                                                     closure_args(name),
                                                     args)),
                        env);
        }
        else
        {
            // TODO check for unlimited recursion
            return apply(eval(name, env), args, env);
        }
    }

    void bind_args(Expr env, Expr vars, Expr vals)
    {
        env_destructuring_bind(env, vars, vals);
    }

    Expr make_call_env_from(Expr lenv, Expr vars, Expr vals)
    {
        Expr cenv = make_env(lenv);
        bind_args(cenv, vars, vals);
        return cenv;
    }

    /* backquote */

    Expr backquote(Expr exp, Expr env)
    {
        if (is_cons(exp))
        {
            if (is_unquote(exp))
            {
                return eval(cadr(exp), env);
            }
            else
            {
                return backquote_list(exp, env);
            }
        }
        else
        {
            return exp;
        }
    }

    Expr backquote_list(Expr seq, Expr env)
    {
        if (seq)
        {
            Expr item = car(seq);
            Expr rest = cdr(seq);
            if (is_unquote_splicing(item))
            {
                return append(eval(cadr(item), env), backquote_list(rest, env));
            }
            else
            {
                return cons(backquote(item, env), backquote_list(rest, env));
            }
        }
        else
        {
            return nil;
        }
    }

    var m_type: TypeImpl;
    var m_dummy: int;
};

/* system */

#if LISP_WANT_SYSTEM_API

System * System::s_instance = nullptr;

System::System()
{
    LISP_ASSERT(s_instance == nullptr);
    s_instance = this;

    m_impl = new SystemImpl();
}

System::~System()
{
    delete m_impl;

    s_instance = nullptr;
}

/* env */

Expr System::make_core_env()
{
    return m_impl->make_core_env();
}

void System::env_defun(Expr env, char const * name, BuiltinFunc func)
{
    m_impl->env_defun(env, name, func);
}

void System::env_defun_println(Expr env, char const * name)
{
    m_impl->env_defun_println(env, name);
}

void System::env_defspecial(Expr env, char const * name, BuiltinFunc func)
{
    m_impl->env_defspecial(env, name, func);
}

void System::env_defspecial_quote(Expr env)
{
    m_impl->env_defspecial_quote(env);
}

void System::env_defspecial_while(Expr env)
{
    m_impl->env_defspecial_while(env);
}

void System::env_defsym(Expr env, char const * name, BuiltinFunc func)
{
    m_impl->env_defsym(env, name, func);
}

/* eval */

Expr System::eval(Expr exp, Expr env)
{
    return m_impl->eval(exp, env);
}

Expr System::eval_body(Expr exps, Expr env)
{
    return m_impl->eval_body(exps, env);
}

void System::load_file(char const * path, Expr env)
{
    m_impl->load_file(path, env);
}

void System::repl(Expr env)
{
    return m_impl->repl(env);
}

#endif

#ifdef LISP_NAMESPACE
}
#endif
