
/* base */

bool is_printable_ascii(U32 ch)
{
    // NOTE we exclude space
    return ch >= 33 && ch <= 126;
}

#define TEMP_BUF_SIZE  4096
#define TEMP_BUF_COUNT 4

char * get_temp_buf(size_t size)
{
    LISP_ASSERT(size <= TEMP_BUF_SIZE);

    static char buf[TEMP_BUF_COUNT][TEMP_BUF_SIZE];
    static int idx = 0;
    char * ret = buf[idx];
    idx = (idx + 1) % TEMP_BUF_COUNT;
    return ret;
}

func i64_as_u64(val: I64): U64
{
    var v: V64;
    v.i = val;
    return v.u;
}

I64 u64_as_i64(U64 val)
{
    V64 v;
    v.u = val;
    return v.i;
}

U32 utf8_decode_one(U8 const * buf)
{
    U8 ch = *buf++;
    if (ch < 0x80)
    {
        return ch;
    }

    // TODO check for leading 0b10 in continuation bytes

    U32 val = 0;
    if ((ch >> 5) == 0x6)
    {
        val |= ch & 0x1f;

        ch = *buf++;
        val <<= 6;
        val |= (ch & 0x3f);
    }
    else if ((ch >> 4) == 0xe)
    {
        val |= ch & 0xf;

        ch = *buf++;
        val <<= 6;
        val |= (ch & 0x3f);

        ch = *buf++;
        val <<= 6;
        val |= (ch & 0x3f);
    }
    else if ((ch >> 3) == 0x1e)
    {
        val |= ch & 0x7;

        ch = *buf++;
        val <<= 6;
        val |= (ch & 0x3f);

        ch = *buf++;
        val <<= 6;
        val |= (ch & 0x3f);

        ch = *buf++;
        val <<= 6;
        val |= (ch & 0x3f);
    }
    else
    {
        LISP_FAIL("illegal utf-8 string\n", val);
    }

    if (val >= 0xd800 && val < 0xe000)
    {
        LISP_FAIL("illegal surrogate pair %" PRIu32 " in utf-8 string\n", val);
    }

    return val;
}
